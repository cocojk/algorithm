
// 탐욕적 알고리즘 레시피 
// 1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
// 2. 각 조각마다 어떤 우선 순위로 선택을 내려야 할 지 결정한다. 이에 대한 직관을 얻기 위해서는 예제 입력이나 그외의 작은 입력을 몇개 손으로 풀어 보는 것이 효율적이다.
// 3. 어떤 방식이 동작할 것 같으면 두 가지의 속성을 증명해 본다
// a) 탐욕적 선택 속성 (greedy choice property)
// 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보이면 된다. 이 증명은 대게 우리가 선택한 답과 다른 최적해가 존재함을 가정하고, 이것을 조작해서 우리가 선택한 답을 포함하는 최적해로 바꿀 수 있음을 보이는 형태로 이루어 진다.
// b) 최적 부분 구조 (optimal substructure)
// 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명한다. 다행히도 대개의 경우 이 속성이 성립하는지 아닌지는 자명하게 알 수 있다. 

// 출전 순서 정하기 문제를 해결하는 탐욕적 알고리즘 
/*
문제

전세계 최대의 프로그래밍 대회 알고스팟 컵의 결승전이 이틀 앞으로 다가왔습니다. 각 팀은 n명씩의 프로 코더들로 구성되어 있으며, 결승전에서는 각 선수가 한 번씩 출전해 1:1 경기를 벌여 더 많은 승리를 가져가는 팀이 최종적으로 우승하게 됩니다. 각 팀의 감독은 대회 전날, 주최측에 각 선수를 출전시킬 순서를 알려 주어야 합니다.

결승전 이틀 전, 한국팀의 유감독은 첩보를 통해 상대 러시아팀의 출전 순서를 알아냈습니다. 이 대회에서는 각 선수의 실력을 레이팅(rating)으로 표현합니다. 문제를 간단히 하기 위해 1:1 승부에서는 항상 레이팅이 더 높은 선수가 승리하고, 레이팅이 같을 경우 우리 선수가 승리한다고 가정합시다.

경기    1   2   3   4   5   6
러시아팀    3,000   2,700   2,800   2,200   2,500   1,900
한국팀  2,800   2,750   2,995   1,800   2,600   2,000
표와 같이 출전 순서를 정했다고 하면 한국팀은 2번, 3번, 5번, 6번 경기에서 승리해 전체 네 경기를 이기게 됩니다. 그러나 대신 4번 경기와 1번 경기에 나갈 선수를 바꾸면 1번 경기만을 제외하고 모든 경기에 승리할 수 있지요. 상대방 팀 선수들의 순서를 알고 있을 때, 어느 순서대로 선수들을 내보내야 승수를 최대화할 수 있을까요?

입력

입력의 첫 줄에는 테스트 케이스의 수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 각 팀 선수의 수 N(1≤N≤100)가 주어집니다. 그 다음 줄에는 N개의 정수로 러시아팀 각 선수의 레이팅이 출전 순서대로 주어지며, 그 다음 줄에는 N개의 정수로 한국팀 각 선수의 레이팅이 무순으로 주어집니다. 모든 레이팅은 1 이상 4000 이하의 정수입니다.

출력

각 테스트 케이스마다 한 줄에 한국팀이 얻을 수 있는 최대 승수를 출력합니다.

예제 입력

3
6
3000 2700 2800 2200 2500 1900
2800 2750 2995 1800 2600 2000
3
1 2 3
3 2 1
4
2 3 4 5
1 2 3 4
예제 출력

5
3
3
*/

int order (const vector<int>& russian, const vector<int>& korean) {
    int n = russian.size(), wins = 0;

    // 아직 남아 있는 선수들의 레이팅 
    multiset<int> ratings(korean.begin(),korean.end());

    for(int rus = 0; rus < n; rus ++) {
        // 가장 레이팅이 높은 한국 선수가 이길 수 없는 경우 
        // 가장 레이팅이 낮은 선수와 경기시킨다.
        if(*ratings.rbegin() < russian[rus]) 
            ratings.erase(ratings.begin());
        // 이외의 경우 이길 수 있는 선수 중 가장 레이팅이 낮은 선수와 경기시킨다.
        else {
            ratings.erase(ratings.lower_bound(russian[rus]));
            ++wins;
        }
    }

    return wins;
}

