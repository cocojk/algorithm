
// 펜윅 트리 : 빠르고 간단한 구간 합 

// 구간 트리의 가장 흔한 사용 예는 바로 구간 합을 빠르게 구하는 것이다.
// 이 경우 구간 트리 대신 쓸 수 있는 구간 트리의 궁극적인 진화 형태로 펜윅 트리 (fenwick tree) 혹은 이진 인덱스 트리 (binary indexed tree)라고 불리는 것이 있다.
// 구간 합 (range sum) : A의 연속된 부분 배열의합. 
// 부분 합 (partial sum) : A의 첫 몇 i개의 원소의 합. 즉, 첫 위치가 A[0]으로 고정된 구간 합.

// range sum 대신 partial sum만을 빠르게 계산할 수 있는 자료 구조를 만들어서 range sum을 계산하는 것.
// 즉, psum[pos]가 있다면, range [i,j]의 합은 psum[j]-psum[i-1]로 구할 수 있다.
// 기존 partial sum 알고리즘 이용가능 (update가 일어나는 경우 O(n)의 시간이 걸린다. 반면, init 시간이 O(n)) <-> 펜윅 트리 update O(lgN) init O(NlgN)

// 부분 합만을 계산한다고 생각해 보면, 구간 트리가 미리 계산해 저장하는 정보의 상당수는 필요가 없다.
//                                          (0,15)16
//                  (0,7)8                                           
//  (0,3)4                                         (8,11)12
//  (0,1)2              (4,5)6                     (8,9)10                (12,13)14
//  (0)1     (2)3       (4)5      (6)7             (8)9     (10)11        (12)13        (14)15

// 예를 들어 (8,15)의 경우 필요가 없다. 만약 15까지 계산이 필요하다하면 (0,15) 이용하면 되기 때문에.
// 따라서, 항상 오른쪽 구간을 지워도 된다. (오른쪽 구간까지 필요하면 parent 참조하면 되기 때문에)
// 구간의 수 정확히 n개 
// 오른쪽 끝 원소들을 보면 이들이 서로 모두 다르다. 이 대응을 이용해 1차원 배열 하나에 각 구간의 합을 저장한다.
// tree[i] = 그림에서 오른쪽 끝 위치가 A[i]인 구간의 합 

// query 
// psum[12]  = tree[12] + tree[11] + tree[7]  - O(lgN) 
// pos에서 끝나는 구간 다음으로 더해야 할 구간을 어떻게 찾아야 할까?
// 오른쪽 끝 위치의 이진수 표현에서 마지막 비트를 지우면 다음 구간을 쉽게 찾을 수 있다.
// 각 숫자의 이진수 표현을 이용해 이 문제를 해결한다. 우선 이를 위해 배열 A[]와 tree[]의 첫 원소의 인덱스를 1로 바꾼다. 모든 원소의 인덱스에 1을 더해주면 된다.
// 각 구간의 길이는 이진수 표현에서 오른쪽 끝에 있는 0의 갯수가 하나 늘때마다 두배로 늘어난다. 
// 예를 들어, 9의 이준수 표현은 1000이고 이 수의 오른쪽 끝에는 0이 세 개이므로 9에서 끝나는 구간의 길이는 2^3=8이 된다. 

// init 
// 펜익 트리를 처음 생성하면 모든 부분 합이 0으로 초기화된다. 
// 구간 트리처럼 도느 구간에 대해 답을 계산하지 않기 때문에 O(n)에 초기화하기가 불가능하다. 따라서 구간 트리의 갱신 연산처럼 각 위치의 값을 변경하는 연산을 통해 내용을 채워넣어야한다.
// 맨 오른쪽에 있는 1인 비트를 스스로에게 더해주는 연산을 반복함녀 해당 위치를 포함하는 구간들을 모두 만날 수 있다. 

// 코드 24.7 펜윅 트리의 완전한 구현 

// 펜윅 트리의 구현, 가상의 배열 A[] 부분 합을 
// 빠르게 구현할 수 있도록 한다. 초기화시에는 A[]의 
// 원소가 전부 0이라고 생각한다.
// 모든 원소에 갯수에 대해서 성립한다. (안될거 같으면 계산해보면 실제로 된다.)
// 트리의 형태가 완전 bst트리의 왼쪽부터 채워나가는 형식으로 구성이된다.
// 예를들어, 원소의 갯수가 5개라면 다음과 같은 트리의 모습을 보인다.
//              (0,4)
//      (0,3)
//  (0,1)   
// (0)      (2)
// 원소의 갯수가 6개인 경우
//              (0,5)
//      (0,3)
//  (0,1)
//  (0)     (2)     (4)
struct FenwickTree {
    vector <int> tree;
    FenwickTree(int n) : tree(n+1) {}
    // A[0..pos]의 부분합을 구한다. 
    int sum (int pos) {
        // 인덱스가 1부터 시작한다고 생각하자.
        ++pos;
        int ret = 0;
        while (pos >0) {
            ret += tree[pos];
            // 다음 구간을 찾기 위해 최종 비트를 지운다.
            pos &= (pos-1);
        }

        return ret;
    }

    // A[pos]에 val을 더한다.
    void add (int pos, int val) {
        ++pos;
        while (pos < tree.size()) {
            tree[pos] += val;
            pos += (pos&-pos);
        }
    }
};

