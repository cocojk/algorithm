/*
   문제

   크리스마스를 맞이하여 산타 할아버지는 전세계의 착한 어린이 K명에게 인형을 사주려고 한다. 산타 할아버지는 인형을 구입하기 위해서 유명한 인형가게인 "놀이터"에 찾아갔다. 놀이터에는 N개의 인형 상자가 한 줄로 진열되어 있고, 각 인형 상자에는 한 개 이상의 인형이 들어 있다. 그리고 놀이터에서는 주문의 편의성을 위해 각 상자에 번호를 붙여 놓았고, 주문은 "H번 상자부터 T번 상자까지 다 주세요."라고만 할 수 있다. (H ≤ T)

   산타 할아버지는 한 번 주문할 때마다, 주문한 상자에 있는 인형들을 모두 꺼내서 각각을 K명에게 정확히 같은 수만큼 나누어 주고, 남는 인형이 없도록 한다.

   한 번 주문할 수 있다면, 가능한 주문 방법은 몇 가지인가?
   여러 번 주문할 수 있다면, 주문이 겹치지 않게 최대 몇 번 주문할 수 있는가? (주문이 겹친다는 것은 어떤 두 주문에 같은 번호의 인형 상자가 포함되는 것을 말한다.)
   입력

   첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. ( T ≤ 60 )

   각 테스트 케이스의 첫 번째 줄에는 인형 상자의 개수 N과 어린이의 수 K가 주어진다.(1 ≤ N, K ≤ 100000)

   두 번째 줄에는 1번 인형 상자부터 N번 인형 상자까지 각 인형 상자에 들어 있는 인형의 개수 Di가 주어진다. ( 1 ≤ i ≤ N, 1 ≤ Di ≤ 100000 )

   출력

   1번에 대한 답과 2번에 대한 답을 한 줄에 하나의 빈칸으로 나누어 출력한다. 1번 답은 매우 클 수 있으므로 20091101로 나눈 나머지를 출력한다.

   예제 입력

   1
   6 4
   1 2 3 4 5 6
   예제 출력

   3 1
*/

// 부분 합을 이용해 크리스마스 인형 문제를 해결하는 두 함수의 구현 
// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 몇 가지 방법으로 살수 있는지 반환한다.
// psum[]의 첫 번째 원소 전에 0을 삽입했다고 가정한다.
int waysToBuy(const vector<int>& psum, int k) {
    const int MOD = 20091101;
    int ret = 0;
    // psum[]의 각 값을 몇 번이나 본 적 있는지 기록한다.
    vector<long long> count(k,0);
    for(int i = 0; i < psum.size(); i++)
        count[psum[i]]++;

    // 두번 이상 본적 있다면 이 값 중 두 개를 선택하는 방법의 수를 더한다.
    for(int i = 0; i < k ; i++)
        if(count[i] >= 2)
            ret = (ret + ((count[i]*(count[i]-1))/2)) % MOD;
    return ret;
}

// D[]의 부분 합 배열 psum[]과 k가 주어질 때, 겹치지 않게 몇 번이나 살 수 있는지 반환한다.
// psum[]의 첫 번째 원소 전에 0을 삽입했다고 가정한다.
int maxBuys(const vector<int>& psum, int k) {
    // ret[i]= 첫 번째 상자부터 i번째 상자까지 고려했을 때 살 수 있는 최대 횟수 
    vector<int> ret(psum.size(),0);
    // prev[s] = psum[]이 s였던 마지막 위치 
    vector<int> prev(k,-1);
    for (int i = 0; i < psum.size(); i++) {
        // i번째 상자를 아예 고려하지 않는 경우 
        if (i > 0)
            ret[i] = ret[i-1];
        else 
            ret[i] = 0;
        // psum[i]를 전에도 본 적이 있으면, prev[psum[i]]+1부터 여기까지 쭉 사본다.
        int loc = prev[psum[i]];
        if (loc != -1) ret[i] = max(ret[i],ret[loc]+1);
        // prev[]에 현재 위치를 기록한다.
        prev[psum[i]] = i;
    }

    return ret.back();
}


