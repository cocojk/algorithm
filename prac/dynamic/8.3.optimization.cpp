
// dynamic programming의 가장 일반적인 사용처는 최적화 문제의 해결이다. 
// optimal substructure 
// 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 

/*
   문제

   6
   1  2
   3  7  4
   9  4  1  7
   2  7  5  9  4
   위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

   입력

   입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

   출력

   각 테스트 케이스마다 한 줄에 최대 경로의 숫자 합을 출력합니다.

   예제 입력

   2
   5
   6
   1  2
   3  7  4
   9  4  1  7
   2  7  5  9  4
   5
   1 
   2 4
   8 16 8
   32 64 32 64
   128 256 128 256 128
   예제 출력

   28
   341
*/

// 삼각형 위의 최대 경로 문제를 푸는 동적 계획법 알고리즘 
int n, triangle[100][100];
int cache[100][100];
// (y,x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path(int y, int x) {
    // base case 
    if(y == n-1) 
        return triangle[y][x];
    // memoization
    int * ret = &cache[y][x];
    if(*ret != -1)
        return *ret;
    return *ret = max(path(y+1,x),path(y+1,x+1)) + triangle[y][x];
}

