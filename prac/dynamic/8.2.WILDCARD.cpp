
/*
   문제

   와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다.

   와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다.

   예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다.

   와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

   입력

   입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

   출력

   각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

   예제 입력

   2
   he?p
   3
   help
   heap
   helpp
   *p*
   3
   help
   papa
   hello
   예제 출력

   heap
   help
   help
   papa
*/

// 와일드카드 문제를 해결하는 동적 계획법 알고리즘 
// running time : O(n^3)

// -1은 아직 답이 계산되지 않았음을 의미한다.
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열 
string W,S;
// 와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w,int s) {
    // 메모이제이션
    int *ret = &cache[w][s];
    if(*ret!=-1)
        return *ret;
    // W[w]와 S[s]를 맞춰 나간다.
    while (s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
            ++w;
            ++s;
    }

    // 더 이상 대응할 수 없으면 왜 while문이 끝나는지 확인한다. 
    // 2. 패턴 끝에 도달해서 끝난 경우 : 문자열도 끝났어야 참 
    if(w==W.size()) 
        return *ret = (s == S.size());
    // 4. *를 만나서 끄난 경우 : *에 글자를 대응해야 할지 재귀호출하면서 확인한다.
    if(W[w] == '*')
        for(int skip = 0; skip+s <= S.size(); skip++)
            if(matchMemoized(w+1,s+skip))
                return *ret = 1;
    // 3. 이 외의 경우에는 모두 대응되지 않는다.
    return *ret = 0;
}

// 최적화 
// running time : O(n^2)

// -1은 아직 답이 계산되지 않았음을 의미한다.
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열 
string W,S;
// 와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w,int s) {
    // 메모이제이션
    int *ret = &cache[w][s];
    if(*ret!=-1)
        return *ret;
    // W[w]와 S[s]를 맞춰 나간다.
    while (s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
        return *ret = matchMemoized(w+1,s+1);
    }

    // 더 이상 대응할 수 없으면 왜 while문이 끝나는지 확인한다. 
    // 2. 패턴 끝에 도달해서 끝난 경우 : 문자열도 끝났어야 참 
    if(w==W.size()) 
        return *ret = (s == S.size());
    // 4. *를 만나서 끄난 경우 : *에 글자를 대응해야 할지 재귀호출하면서 확인한다.
    if(W[w] == '*') {
        if(matchMemoized(w+1,s) || (s < S.size() && matchMemoized(w,s+1))
                return *ret = 1;
    
    // 3. 이 외의 경우에는 모두 대응되지 않는다.
    return *ret = 0;
}

