
/*
   문제

   단 한 번도 함락된 적이 없다는 성채도시 미나스 아노르에는 반지름이 8 킬로미터나 되는 거대한 원형 성벽, 람마스 에코르가 있습니다. 도시 전체를 감싸는 이 거대한 성벽에는 n 개의 초소가 배치되어 있습니다. 각 초소들은 해당 위치를 중심으로 반지름 ri 의 원 내부를 감시할 수 있는데, 성벽의 구조 때문에 초소는 불규칙하게 배치되어 있고 초소마다 감시할 수 있는 범위도 모두 다릅니다.

   castlewatch.png

   위 그림에서 굵은 실선은 성벽, 별은 초소의 위치, 그리고 점선은 각 초소가 감시할 수 있는 영역을 나타냅니다. 최소의 인원으로 성벽의 모든 부분을 감시하기 위해, 일부 초소에만 병사를 배치하려고 합니다. 각 초소의 위치와 감시 범위가 주어질 때, 성벽의 모든 부분을 감시하기 위해 필요한 최소한의 병사 수를 계산하는 프로그램을 작성하세요.

   문제를 간단하게 하기 위해 성벽은 두께가 없는 원이고 초소는 점이라고 가정합니다.

   입력

   입력의 첫 줄에는 테스트 케이스의 수 c (c <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 초소의 개수 n (1 <= n <= 100) 이 주어지며, 그 후 n 줄에 각 3 개의 실수로 각 초소의 위치 yi, xi, 그리고 감시 범위 ri (0 < ri <= 16.001) 가 주어집니다.

   성벽은 (0,0) 을 중심으로 하는 반지름 8 인 원으로, 모든 초소는 이 성벽 위에 위치합니다.

   출력

   각 테스트 케이스마다 한 줄에 필요한 최소의 병사 위치를 출력합니다. 만약 어떻게 하더라도 성벽의 모든 부분을 감시할 수 없다면 IMPOSSIBLE 을 대신 출력합니다. 입력에 주어지는 초소의 좌표, 혹은 감시 범위가 최대 0.0000001 만큼 변하더라도 답은 변하지 않는다고 가정해도 좋습니다.

   예제 입력

   3
   10
   7.02066050 -3.83540431 4.0
   -7.23257714 -3.41903904 2.0
   0.00000000 -8.00000000 8.0
   -8.00000000 -0.00000000 4.8
   -6.47213595 4.70228202 3.2
   -4.70228202 6.47213595 4.8
   7.60845213 -2.47213595 1.6
   -2.47213595 -7.60845213 8.8
   6.47213595 4.70228202 7.6
   -0.00000000 8.00000000 4.8
   4
   8.00000000 0.00000000 8.00
   0.00000000 -8.00000000 8.00
   -8.00000000 -0.00000000 8.00
   1.25147572 7.90150672 5.40
   1
   8 0 15.99
   예제 출력

   5
   4
   IMPOSSIBLE
*/

// step1. 미나스 아노르 문제의 원들을 중심각 구간으로 바꾸기
// 다루기 쉬운 꼴로 변형 
const double pi = 2.0 * acos(0);
int n;
double y[100], x[100], r[100];
pair<double,double> ranges[100];
void convertToRange() {
    for (int i = 0; i < n; i++) {
        // atan2의 반환 값은 [-pi,pi]의 범위 안에 있으므로 fmod()을 이용해 강제로 [0,2pi] 범위로 바꾼다. 
        // fmod() : double 형 나눗셈의 나머지를 구한다. 
        double loc = fmod(2*pi atan2(y[i],x[i]), 2*pi);
        double range = 2.0 * asin(r[i]/2.0/8.0);
        ranges[i] = make_pair(loc-range, loc+range);
    }

    // 각 구간을 시작 위치가 작은 것부터 오게끔 정려한다.
    sort(ranges, ranges+n);
}

// step2. 미나스 아노르 문제를 선형 문제로 변형해서 푸는 알고리즘 
// 중심각으로 문제를 바꾸더라도 선형 문제가 아니라 원형 문제 (양끝이 연결된 문제) 
// 따라서 양끝을 처리하는 작업을 해줘야 선형 문제로 쉽게 풀 수 있다. 
// 1. 0을 덮은 구간은 최적해에서 최대 2개이다.
// 귀류법 : 0을 덮는 구간이 3개 이상이라면, 0을 덮는 구간 중 왼쪽으로 가장 먼 구간, 오른쪽으로 가장 먼 구간을 선택했을 때, 이 두 구간은 모든 구간의 합집합을 덮는다. 따라서, 가정이 모순이다. 
// 2. 0을 덮는 구간이 최적해에 두개 일 경우, 
// 2.1) 두 구간의 중심이 0을 사이에 두는 경우 
// 둘 중 어느 구간을 선택하더라도 나머지 부분을 선분으로 펴서 풀면 최적해를 얻을 수 있다. 
// 즉, 한개를 선택한 상태에서 선형 문제를 풀면 나머지 한개는 답으로 따라온다. 
// 2.2) 두 구간의 중심이 0을 사이에 두지 않는 경우 -> 중심이 0에 가까운 구간을 선택했을때 풀면 된다.(나머지 하나도 선형 문제에서 답으로 채택됨)
const int INF = 987654321;
int n;
pair<double,double> ranges[100]; // 각 원이 덮는 중심각의 구간 
// 0을 덮을 구간을 선택하고 나머지를 선형으로 푼다.
int solveCircular() {
    int ret = INF;
    // 각 구간을 시작 위치의 오름차순으로 정렬한다.
    sort(ragnes, ragnes+n);
    // 0을 덮을 구간을 선택하자.
    for (int i = 0; i < n; i++) 
        if(ranges[i].first <= 0 || ranges[i].second >= 2*pi) {
            // 이 구간이 덮는 부분을 빼고 남는 중심각의 범위는 다음과 같다.
            double begin = fmod(ranges[i].second,2*pi);
            double end = fmod(ranges[i].first + 2*pi,2*pi);
            // [begin, end] 선분을 주어진 구간을 사용해서 덮는다.
            ret = min(ret, 1 + solveLinear(begin,end));
        }

    return ret;
}

// step3. 선분을 덮는 최소 구간 수를 계산하는 탐욕적 알고리즘 
const int INF = 987654321;
// [begin, end] 구간을 덮기 위해 선택할 최소한의 구간 수를 반환한다.
// ranges는 시작 위치의 오름차순으로 정렬되어 있다고 가정하자.
int solveLinear(double begin, double end) {
    int used = 0, idx = 0;
    // 덮지 못한 선분이 남아 있는 동안 계속한다.
    while(begin < end) {
        // begin보다 이전에서 시작하는 구간 중 가장 늦게 끝나는 구간을 찾는다.
        double maxCover = -1;
        while (idex < n && ranges[idx].first <= begin) {
            maxCover = max(maxCover,ranges[idx].second);
            ++idx;
        }

        // 덮을 구간을 찾지 못한 경우 
        if(maxCover <= begin)
            return INF;
        // 선분의 덮인 부분을 잘라낸다.
        begin = maxCover;
        ++used;
    }

    return used;
}


