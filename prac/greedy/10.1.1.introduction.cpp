
// 탐욕법 (greedy method)
// 가장 직관적인 알고리즘 설계 패러다임 중 하나 
// 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서
// 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없다. 
// 그러나 모든 선택지를 고려해보고 그 중 전체 답이 가장 좋을 것을 찾는 두 방법과는 달리, 
// 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다. 
// * 탐욕법이 사용되는 경우 *
// 1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제인 경우 
// 2. 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어려운 경우, 근사해를 찾는 경우 

// 탐욕법 문제는 당연히 dynamic으로 풀 수 있다. 하지만, dynamic이 시간이나 메모리가 너무 많이 잡아먹는 경우 greedy로 접근한다.

// 예제 : 회의실 예약 
// 활동 선택 문제(activity selection problem), 회사에 회의실이 하나 밖에 없는데, n개의 팀이 각각 회의하고 싶은 시간을 제출 했을 때, 두 팀이 회의실을 같이 쓸 수는 없기 때문에 이 중 서로 겹치지 않는 회의들만을 골라내서 진행할 경우 최대 몇개나 선택할 수 있을까?
// 방법 1. brute force 2^n 가지 방법 수 
// 방법 2. greed method
// 1. 짧은 회의부터 하나하나 순회하면서 앞의 것들과 겹치지 않는 것들을 추가하는 방법 - 모순 존재 
// 2. 가장 먼저 끝나는 회의 선택 

// 정당성 증명 

// 1. 탐욕적 선택 속성 (greedy choice property) 
// 한 스텝에서 탐욕적으로 선택해도 되는가?
// 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있냐?
// 이 속성이 성립할 경우, 우리가 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나이다. 
// 위 예제의 경우 가장 종료 시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.가 성립해야 한다. 
// 최적해 중에서 첫 번째로 개최되는 회의를 지우고 가장 종료 시간이 빠른 회의를 추가할 수 있다 -> 속성 성립 

// 2. 최적 부분 구조 (optimal substructure)
// 항상 탐욕적으로 선택한 것이 전체적으로 최적화인가?
// 항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있냐?
// 대게 매우 자명해서 따로 증명할 필요가 없는 경우 대부분.
// 첫 번째 회의를 잘 선택하고 겹치는 회의를 모두 걸러냈다면, 남은 회의 중에 당연히 최대한 많은 회의를 선택해야한다.

// 회의실 예약 문제를 해결하는 탐욕적 알고리즘 

// 각 회의는 [begin,end) 구간 동안 회의실을 사용한다.
int n;
int begin[100], end[100];
int schedule() {
    // 일찍 끝나는 순서대로 정렬한다.
    vector<pair<int,int> >  order;
    
    for(int i = 0; i < n; i++)
        order.push_back(make_pair(end[i],begin[i]));
    sort(order.begin(),order.end());

    // earliest : 다음 회의가 시작할 수 있는 가장 빠른 시간 
    // selected: 지금까지 선택한 회의의 수  

    int earliest = 0, selected = 0;
    for(int i = 0; i < order.size; i++) {
        int meetingBegin = order[i].second, meetingEnd = order[i].first;

        if(earliest <= meetingBegin)  {
            // earliest를 마지막 회의가 끝난 시간 이후로 갱신한다. 
            earliest = meetingEnd;
            ++selected;
        }
    }

    return selected;
}


