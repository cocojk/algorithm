
// 경우의 수와 확률
// 경우의 수의 많은 경우 재귀적인 특징을 가지고 있다. 

// 오버플로 유의하기 
// 대게 답은 입력의 크기에 대해 지수적으로 증가.

// 예제: 타일링 방법의 수 세기 
/*
   문제

   2xn 크기의 사각형을 2x1 크기의 사각형으로 빈틈없이 채우는 경우의 수를 구하는 프로그램을 작성하세요.

   예를 들어 n=5라고 하면 다음 그림과 같이 여덟 가지의 방법이 있습니다.

   경우의 수는 n이 커지면 아주 커질 수 있으므로, 1000000007으로 나눈 값을 대신 출력하세요.

   입력

   입력의 첫 줄에는 테스트 케이스의 수(C <= 50)가 주어집니다. 그후 C줄에 각각 1개의 자연수로 n(1 <= n <= 100)이 주어집니다.

   출력

   각 테스트 케이스마다 한 줄에 경우의 수를 1000000007로 나눈 나머지를 출력합니다.

   예제 입력

   3
   1
   5
   100
   예제 출력

   1
   8
   782204094
*/

// 타일링의 수를 세는 동적 계획법 알고리즘 
const int MOD = 1000000007;
int cache[101];
// 2*width 크기의 사각형을 채우는 방법의 수를 MOD로 나눈 나머지를 반환한다.
int tiling (int width) {
    // base case : width가 1 이하 일때
    if(width <= 1) return 1;
    // memoization
    int* ret = &cache[width];
    if (*ret != -1)
        return *ret;
    return *ret = (tiling(width-2) + tiling(width-1))%MOD;
}

// 예제 :  삼각형 위의 최대 경로 개수 세기 
/*
   문제

   6
   1  2
   3  7  4
   9  4  1  7
   2  7  5  9  4
   위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

   입력

   입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

   출력

   각 테스트 케이스마다 한 줄에 최대 경로의 숫자 합을 출력합니다.

   예제 입력

   2
   5
   6
   1  2
   3  7  4
   9  4  1  7
   2  7  5  9  4
   5
   1 
   2 4
   8 16 8
   32 64 32 64
   128 256 128 256 128
   예제 출력

   28
   341
*/

// 삼각형 위의 최대 경로의 수를 찾는 동적 계획법 알고리즘 
int countCache[100][100];
// (y,x)에서 시작해서 맨 아래줄까지 내려가는 경로 중 최대 경로의 개수를 반환한다.
int count (int y, int x) {
    // base case : 맨 아래줄에 도달한 경우 
    if (y == n-1) return 1;
    // memoization
    int* ret = &countCache[y][x];
    if(*ret != -1)
        return *ret;
    *ret = 0;
    if(path2(y+1,x+1) >= path2(y+1,x)) *ret += count(y+1,x+1);
    if(path2(y+1,x+1) <= path2(y+1,x)) *ret += count(y+1,x);
    return *ret;
}

// 예제 : 우물을 기어오르는 달팽이 
/* 
   문제

   깊이가 n 미터인 우물의 맨 밑바닥에 달팽이가 있습니다. 이 달팽이는 우물의 맨 위까지 기어올라가고 싶어하는데, 달팽이의 움직임은 그 날의 날씨에 좌우됩니다. 만약 비가 내리면 달팽이는 하루에 2미터를 기어올라갈 수 있지만, 날이 맑으면 1미터밖에 올라가지 못합니다.

   여름 장마가 찾아와, 앞으로 m 일간 각 날짜에 비가 올 확률이 정확히 75%일 전망입니다. m 일 안에 달팽이가 우물 끝까지 올라갈 확률을 계산하는 프로그램을 작성하세요.

   입력

   입력의 첫 줄에는 테스트 케이스의 수 C(1≤C≤50) 가 주어집니다. 그 후 각 줄에 우물의 깊이 n(1≤n≤1000)과 장마 기간의 길이 m(1≤m≤1000) 이 주어집니다.

   출력

   각 테스트 케이스마다 한 줄에 m일 안에 달팽이가 우물을 탈출할 수 있을 확률을 출력합니다. 10−7 이하의 상대/절대 오차가 있는 답은 정답으로 인정됩니다.

   예제 입력

   4
   5 4
   5 3
   4 2
   3 2
   예제 출력

   0.9960937500
   0.8437500000
   0.5625000000
   0.9375000000
*/

// 우물을 기어오르는 달팽이 문제를 해결하는 동적 계획법 알고리즘 
int n,m;
int cache[MAX_N][2*MAX_N+1];
// 달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,
// m일 전까지 n미터를 기어올라 갈 수 있는 경우의 수 
int climb (int days, int climbed) {
    // base case : m일이 모두 지난 경우 
    if (days == m) return climbed >= n ? 1 : 0;
    // memoization
    int* ret = &cache[days][climbed];
    if(*ret != -1)
        return *ret;
    return *ret = 0.75*climb(days+1,climbed+1) + 0.25*climb(days+1,climbed+2);
}

